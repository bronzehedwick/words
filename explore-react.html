<!DOCTYPE html>
<html><head><title>Explore React</title><style type="text/css">body {
  font: normal 18px/1.6 sans-serif;
  padding-top: 10px;
}

h1, h2, h3, h4, h5, h6 {
  font-family: serif;
}

h2, h3, h4, h5, h6 {
  padding-top: 50px;
}

.heading a,
.heading a:hover {
  color: #000;
  text-decoration: none;
}

.heading a:hover:after {
  content: ' #';
  color: #999;
}

code {
  background: #EEE;
  padding: 2px;
  border-radius: 2px;
}

pre > code {
  display: block;
}

.code-ref pre {
  margin: 0;
  max-width: 100%;
  overflow-x: auto;
  background: #EEE;
  padding: 5px;
  border-radius: 3px;
}

.code-ref p {
  font-size: 12px;
  margin: 10px 0 0 0;
  padding: 2px 0;
}

.code-ref p a:link,
.code-ref p a:visited {
  color: #000;
}

.code-ref p a:hover {
  color: #C00;
}

.wiki-link {
  white-space: nowrap;
}

.content {
  margin: 0 auto;
  width: 80%;
  max-width: 1200px;
  min-width: 300px;
}

.topic {
  border-top: 1px solid #000;
  margin-bottom: 150px;
}

.incoming {
  font-size: 14px;
  color: #999;
  border-top: 1px solid #EEE;
}

.incoming h2 {
  font-size: 14px;
  font-weight: normal;
  font-style: italic;
}

h1:target,
h2:target,
h3:target,
h4:target,
h5:target,
h6:target {
  -webkit-animation: highlight 2s ease;
  animation: highlight 2s ease;
}

@-webkit-keyframes highlight {
  from {
    background: #FDFFA2;
  }

  to {
    background: white;
  }
}

@keyframes highlight {
  from {
    background: #FDFFA2;
  }

  to {
    background: white;
  }
}

h1.sticky {
  position: fixed;
  top: 0;
  left: 0;
  background: #fff;
  margin: 0;
  width: 80%;
  padding: 0.9em 9.5% 0 10.5%;
  border-bottom: 1px solid #EEE;
}

h1.sticky small {
  display: block;
  font-size: 0.5em;
  font-style: italic;
  line-height: 0.5;
  color: #333;
}
</style></head><body><div class="content"><div class="topic" data-topic-id="headingId"><h1 id="explore-react" class="heading">Explore React</h1><div class="topic-content"><p>Ever try to make sense of a huge codebase? It doesn&#39;t take very long before the vertigo kicks in.  When looking at something like React, what we see is the cumulative result of years of effort from hundreds of very bright people.  So how do we mere mortals even begin to understand all of the careful decisions that have gone into it?  Today might be the day you take the first couple of steps.</p>
<p>It&#39;s helpful to understand the basic concepts behind React, and and much has already been <a href="#">written about the concepts behind React&#39;s architecture</a>. I encourage you to read up if you&#39;re interested, but it&#39;s not essential for our exploration today.</p>
<h2 class="heading" id="explore-react:hello-world" data-topic="Explore React">Hello World</h2><p>Let&#39;s start with the most simple of examples, the Hello World. If you&#39;ve done any tutorials then something like this should look familiar:</p>
<pre><code class="lang lang-js">React.render(
  React.createElement(&#39;h1&#39;, null, &#39;Hello, world!&#39;),
  document.getElementById(&#39;example&#39;)
);
</code></pre>
<p>Not a lot of action here on the surface. We create an <code>h1</code> element and render it to the DOM node with ID of <code>example</code>.</p>
<p>Now, if our only goal was to get our message onto the screen we could just set some innerHTML and we&#39;d be done. With React, there&#39;s a little more involved because it&#39;s not really trying to solve the problem of rendering content once. When dealing with content that changes in response to signals from a user or a server, the innerHTML approach soon becomes painful to maintain. We&#39;ll be taking a look inside the render function to see some of the ways it tries to solve this problem.</p>
<p>So let&#39;s start with <code>React.render</code> (you can use the <em>&quot;Source&quot;</em> link below to open the entire file if you&#39;d like to see it in context):</p>
<div class="code-ref" data-lines="432,432"><pre><code class="lang lang-js">  render: function(nextElement, container, callback) {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L432">src/browser/ui/ReactMount.js:432</a></p></div><p>A rough overview of what we see in this function:</p>
<ol>
<li><a href="#elements:check-if-an-object-is-a-valid-element">Make sure we&#39;re rendering a valid element</a></li>
<li><a href="#explore-react:replace-it-or-reuse-it-">Work out whether to replace or reuse the previous element</a></li>
<li><a href="#explore-react:render-a-new-component">Finally render a new component</a></li>
</ol>
<p>As we go we&#39;ll also see examples of:</p>
<ul>
<li><a class="wiki-link" href="#the-invariant-function" data-topic="The invariant function" data-subheading="undefined">The invariant function</a></li>
<li><a class="wiki-link" href="#dev-environment" data-topic="Dev Environment" data-subheading="undefined">Dev Environment</a></li>
</ul>
<h2 class="heading" id="explore-react:make-sure-we-39-re-rendering-a-valid-element" data-topic="Explore React">Make sure we&#39;re rendering a valid element</h2><p>Coming soon...</p>
<p>Some more notes on <a class="wiki-link" href="#elements" data-topic="Elements" data-subheading="undefined">Elements</a></p>
<h2 class="heading" id="explore-react:replace-it-or-reuse-it-" data-topic="Explore React">Replace it or reuse it?</h2><p>Coming soon...</p>
<h2 class="heading" id="explore-react:render-a-new-component" data-topic="Explore React">Render a new component</h2><p>Finally we&#39;ve determined that there&#39;s no existing component, and we want to render a new one. We call the <code>_renderNewRootComponent</code> function:</p>
<div class="code-ref" data-lines="492,496"><pre><code class="lang lang-js">    var component = ReactMount._renderNewRootComponent(
      nextElement,
      container,
      shouldReuseMarkup
    ).getPublicInstance();
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L492-L496">src/browser/ui/ReactMount.js:492,496</a></p></div><p>Let&#39;s take a look at where that function is defined:</p>
<div class="code-ref" data-lines="377,381"><pre><code class="lang lang-js">  _renderNewRootComponent: function(
    nextElement,
    container,
    shouldReuseMarkup
  ) {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L377-L381">src/browser/ui/ReactMount.js:377,381</a></p></div><ul>
<li>TODO: warn against nested update:</li>
</ul>
<div class="code-ref" data-lines="385,391"><pre><code class="lang lang-js">    warning(
      ReactCurrentOwner.current == null,
      &#39;_renderNewRootComponent(): Render methods should be a pure function &#39; +
      &#39;of props and state; triggering nested component updates from &#39; +
      &#39;render is not allowed. If necessary, trigger nested updates in &#39; +
      &#39;componentDidUpdate.&#39;
    );
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L385-L391">src/browser/ui/ReactMount.js:385,391</a></p></div><ul>
<li>TODO: instantiate component and register it. This gives us an ID that is used to refer to the component internally.</li>
</ul>
<div class="code-ref" data-lines="393,397"><pre><code class="lang lang-js">    var componentInstance = instantiateReactComponent(nextElement, null);
    var reactRootID = ReactMount._registerComponent(
      componentInstance,
      container
    );
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L393-L397">src/browser/ui/ReactMount.js:393,397</a></p></div><ul>
<li>TODO: batch the update</li>
</ul>
<div class="code-ref" data-lines="403,409"><pre><code class="lang lang-js">    ReactUpdates.batchedUpdates(
      batchedMountComponentIntoNode,
      componentInstance,
      reactRootID,
      container,
      shouldReuseMarkup
    );
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L403-L409">src/browser/ui/ReactMount.js:403,409</a></p></div></div></div>
<div class="topic" data-topic-id="headingId"><h1 id="elements" class="heading">Elements</h1><div class="topic-content"><p>React keeps the definition of an &quot;element&quot; very simple. Rather than trying to abstract the general behaviour of every possible kind of element, a <code>ReactElement</code> is just a javascript object which follows a certain strucutre.</p>
<h2 class="heading" id="elements:what-makes-a-valid-element-" data-topic="Elements">What makes a valid element?</h2><p>How does React know if it is dealing with an element or some other type of object? Often when faced with this question you might reach for <code>instanceof</code> but a decision was made here to use the more flexible <a href="https://en.wikipedia.org/wiki/Duck_typing">Duck Typing</a> approach. There&#39;s a reference to this in the comments:</p>
<div class="code-ref" data-lines="443,443"><pre><code class="lang lang-js">        // Check if it quacks like an element
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L443">src/browser/ui/ReactMount.js:443</a></p></div><p>Stepping into the <code>isValidElement</code> function we check for the element&#39;s &quot;quack&quot; by looking for the presence of a special flag, <code>_isReactElement</code>:</p>
<div class="code-ref" data-lines="241,241"><pre><code class="lang lang-js">  var isElement = !!(object &amp;&amp; object._isReactElement);
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/classic/element/ReactElement.js#L241">src/classic/element/ReactElement.js:241</a></p></div><p>The flag is set on the <code>ReactElement</code> prototype defined earlier in that same file:</p>
<div class="code-ref" data-lines="139,143"><pre><code class="lang lang-js">// We intentionally don&#39;t expose the function on the constructor property.
// ReactElement should be indistinguishable from a plain object.
ReactElement.prototype = {
  _isReactElement: true
};
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/classic/element/ReactElement.js#L139-L143">src/classic/element/ReactElement.js:139,143</a></p></div></div></div>
<div class="topic" data-topic-id="headingId"><h1 id="registering-a-component" class="heading">Registering a component</h1><div class="topic-content"><ul>
<li>TODO: monitor scrolling (so that React can handle this internally):</li>
</ul>
<div class="code-ref" data-lines="363,363"><pre><code class="lang lang-js">    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L363">src/browser/ui/ReactMount.js:363</a></p></div><ul>
<li>TODO: register the container</li>
</ul>
<div class="code-ref" data-lines="365,365"><pre><code class="lang lang-js">    var reactRootID = ReactMount.registerContainer(container);
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L365">src/browser/ui/ReactMount.js:365</a></p></div><ul>
<li>store a reference to the component instance by ID:</li>
</ul>
<div class="code-ref" data-lines="366,366"><pre><code class="lang lang-js">    instancesByReactRootID[reactRootID] = nextComponent;
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L366">src/browser/ui/ReactMount.js:366</a></p></div></div></div>
<div class="topic" data-topic-id="headingId"><h1 id="react-ids" class="heading">React IDs</h1><div class="topic-content"><ul>
<li><p>TODO: how are IDs generated?</p>
</li>
<li><p>TOOD: how are they used?</p>
</li>
</ul>
</div></div></div><script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
function dedupe (acc, item) {
  if (acc.indexOf(item) === -1) { acc.push(item); }
  return acc;
}

module.exports = dedupe;

},{}],2:[function(require,module,exports){
/*

  Create a unique anchor ID by converting the heading text into a suitable format.

*/
module.exports = function getHeadingId (raw) {
  return raw.trim().toLowerCase().replace(/[^\w]+/g, '-');
};

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')
require('html-element')

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        var m = split(string, /([\.#]?[a-zA-Z0-9_:-]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  e.style.setProperty(s, l[k][s])
              })(s, l[k][s])
            }
          } else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function isText (el) {
  return el && el.nodeName === '#text' && el.nodeType == 3
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}

},{"browser-split":5,"class-list":6,"html-element":3}],5:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],6:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":7}],7:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],8:[function(require,module,exports){
var h = require('hyperscript');
var innerText = require('./inner-text');

function addAnchor (header) {
  var headerText = innerText(header);
  var anchor = h('a', {
    href: '#' + header.id
  }, headerText);

  header.innerHTML = anchor.outerHTML;
}

module.exports = addAnchor;

},{"./inner-text":9,"hyperscript":4}],9:[function(require,module,exports){
function innerText (elem) {
  return elem.innerText || elem.textContent;
}

module.exports = innerText;

},{}],10:[function(require,module,exports){
var h = require('hyperscript');
var d = document;

var addAnchor = require('./add-anchor');
var dedupe = require('../lib/dedupe');
var getHeadingId = require('../lib/get-heading-id');
var innerText = require('./inner-text');
var setupHighlighter = require('./setup-highlighter');

function getTopicElem (id) {
  return d.getElementById(id);
}

function getContentHolderElem () {
  return d.querySelector('.content');
}

function showTopic (topic) {
  var elem = (typeof topic === 'string') ?
      getTopicElem(topic) :
      topic;

  if (!elem) {
    throw new Error('topic not found: ' + topic);
  }
}

function getCurrentLocationHash () {
  return window.location.hash.replace(/^\#/, '');
}

function handleHashChange (event) {
  var hash = getCurrentLocationHash();
  showTopic(hash);
}

function findNearestHeading (elem) {
  var prev;
  while (elem) {
    prev = elem.previousElementSibling;
    if (!prev) {
      prev = elem.parentElement;
    }

    if (!prev) { throw new Error('no heading found'); }

    // found a heading
    if (prev.nodeName.toLowerCase().match(/^h(\d)$/)) {
      return prev;
    }

    // keep stepping back/up until a heading is found
    elem = prev;
  }
}

function createIncomingLinksElem (topicHeading) {
  var currentTopicId = getHeadingId(topicHeading);
  var foundLinks = d.querySelectorAll('a[data-topic="' + topicHeading + '"]');
  var foundHeadings = [].map.call(foundLinks, findNearestHeading)
      .reduce(dedupe, [])
      .filter(function (elem) {
        var id = elem.getAttribute('id');

        // filter out this item if it is a link from within the same topic
        if (id === currentTopicId ||
            id.indexOf(currentTopicId + ':') === 0) { return false; }

        return true;
      });

  if (!foundHeadings.length) { return null; }

  var listItems = foundHeadings.map(function (elem) {
    var parts;
    var topicHeading;
    var subHeading;
    var id = elem.getAttribute('id');

    if (elem.nodeName === 'H1') {
      topicHeading = innerText(elem);
      parts = [topicHeading];
    }
    else {
      topicHeading = elem.getAttribute('data-topic');
      subHeading = innerText(elem);
      parts = [topicHeading, subHeading];
    }

    var anchorElem = h('a', { href: '#' + id });
    anchorElem.innerHTML = parts.join('&rarr;');

    return h('li', null, anchorElem);
  });

  var elem = h('div.incoming', null, [
    h('h2', null, 'Linked from:'),
    h('ul', null, listItems)
  ]);

  return elem;
}

function getHeadingOffsets () {
  return [].map.call(d.querySelectorAll('.heading'), function(heading) {
    var buffer = heading.nodeName.toLowerCase() === 'h1' ? 50 : 10;
    return heading.offsetTop - buffer;
  });
}

function updateStickyHeader (headingOffsets) {
  var container = d.body;
  var stickyElem = d.querySelector('h1.sticky');
  var scrollTop = container.scrollTop;
  var found;

  // find the first heading equal or greater than the scroll offset
  for (var i = 0; i < headingOffsets.length; i += 1) {
    if (headingOffsets[i] >= scrollTop) { found = i; break; }
  }

  if (found === undefined) { found = headingOffsets.length; }

  // we actually want the heading before
  found = Math.max(0, found - 1);

  var heading = d.querySelectorAll('.heading')[found];
  var topic = heading.getAttribute('data-topic');

  stickyElem.innerHTML = !!topic ?
    '<small>' + topic + '</small>' + innerText(heading):
    innerText(heading);
}

// ----

window.onhashchange = handleHashChange;

[].forEach.call(d.querySelectorAll('.content > .topic'), function (topicElem) {
  var topicId = topicElem.getAttribute('id');
  var h1 = topicElem.querySelector('h1');
  var heading = innerText(h1);

  var elem = createIncomingLinksElem(heading);
  if (elem) {
    topicElem.appendChild(elem);
  }
});

[].forEach.call(d.querySelectorAll('.heading'), addAnchor);

var stickyElem = h('h1.sticky');
d.body.appendChild(stickyElem);

var headingOffsets = getHeadingOffsets();
var update = updateStickyHeader.bind(null, headingOffsets);
update();
d.onscroll = update;

setTimeout(setupHighlighter, 100);

},{"../lib/dedupe":1,"../lib/get-heading-id":2,"./add-anchor":8,"./inner-text":9,"./setup-highlighter":11,"hyperscript":4}],11:[function(require,module,exports){
var d = document;
var h = require('hyperscript');

// load syntax highlighting code
function loadHighlighter () {
  var headElem = d.querySelector('head');

  headElem.appendChild(h('link', {
    rel: 'stylesheet',
    href: 'http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css'
  }));

  headElem.appendChild(h('script', {
    src: 'http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js'
  }));

  var interval = setInterval(function () {
    if (!!window.hljs) {
      clearInterval(interval);
      applyHighlighter();
    }
  }, 100);
}

function applyHighlighter () {
  [].forEach.call(d.querySelectorAll('code.lang'), hljs.highlightBlock);
}

module.exports = loadHighlighter;

},{"hyperscript":4}]},{},[10]);
</script></body></html>