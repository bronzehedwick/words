<!DOCTYPE html>
<html><head><title>Explore React</title><style type="text/css">body {
  font: normal 18px/1.6 sans-serif;
  padding-top: 10px;
}

h1, h2, h3, h4, h5, h6 {
  font-family: serif;
}

h2, h3, h4, h5, h6 {
  padding-top: 50px;
}

.heading a,
.heading a:hover {
  color: #000;
  text-decoration: none;
}

.heading a:hover:after {
  content: ' #';
  color: #999;
}

code {
  background: #EEE;
  padding: 2px;
  border-radius: 2px;
}

pre > code {
  display: block;
}

.code-ref pre {
  margin: 0;
  max-width: 100%;
  overflow-x: auto;
  background: #EEE;
  padding: 5px;
  border-radius: 3px;
}

.code-ref p {
  font-size: 12px;
  margin: 10px 0 0 0;
  padding: 2px 0;
}

.code-ref p a:link,
.code-ref p a:visited {
  color: #000;
}

.code-ref p a:hover {
  color: #C00;
}

.wiki-link {
  white-space: nowrap;
}

.content {
  margin: 0 auto;
  width: 80%;
  max-width: 1200px;
  min-width: 300px;
}

.topic {
  border-top: 1px solid #000;
  margin-bottom: 150px;
}

.incoming {
  font-size: 14px;
  color: #999;
  border-top: 1px solid #EEE;
}

.incoming h2 {
  font-size: 14px;
  font-weight: normal;
  font-style: italic;
}

h1:target,
h2:target,
h3:target,
h4:target,
h5:target,
h6:target {
  -webkit-animation: highlight 2s ease;
  animation: highlight 2s ease;
}

@-webkit-keyframes highlight {
  from {
    background: #FDFFA2;
  }

  to {
    background: white;
  }
}

@keyframes highlight {
  from {
    background: #FDFFA2;
  }

  to {
    background: white;
  }
}

h1.sticky {
  position: fixed;
  top: 0;
  left: 0;
  background: #fff;
  margin: 0;
  width: 80%;
  padding: 0.9em 9.5% 0 10.5%;
  border-bottom: 1px solid #EEE;
}

h1.sticky small {
  display: block;
  font-size: 0.5em;
  font-style: italic;
  line-height: 0.5;
  color: #333;
}
</style></head><body><div class="content"><div class="topic" data-topic-id="headingId"><h1 id="explore-react" class="heading">Explore React</h1><div class="topic-content"><p>Ever try finding your way around a huge codebase? It doesn&#39;t take very long before the vertigo kicks in.  When looking at something like React, what we see is the cumulative result of years of effort from hundreds of very bright people.  So how do we mere mortals even begin to understand all of the careful decisions that have gone into it?  Today might be the day you take the first couple of steps.</p>
<p>It&#39;s helpful to understand the basic concepts behind React, and and much has already been written about <a href="#">the concepts behind React&#39;s architecture</a>. I encourage you to read up if you&#39;re interested, but it&#39;s not essential for our exploration today.</p>
<h2 class="heading" id="explore-react:hello-world" data-topic="Explore React">Hello World</h2><p>This is also my first journey in to the React codebase so we&#39;ll start with the basics and see what we find. Let&#39;s begin with the most simple of examples, the Hello World. If you&#39;ve done any tutorials then something like this should look familiar:</p>
<pre><code class="lang lang-js">React.render(
  React.createElement(&#39;h1&#39;, null, &#39;Hello, world!&#39;),
  document.getElementById(&#39;example&#39;)
);
</code></pre>
<p>Not a lot of action on the surface here. We create an <code>h1</code> element and render it to the DOM node with ID of <code>example</code>.</p>
<p>Now, if our only goal was to get our message onto the screen we could just set some innerHTML and we&#39;d be done. With React, there&#39;s a little more involved because it&#39;s not really trying to solve the problem of putting content on a screen. Rendering <em>changes</em> to content is where React&#39;s strength shines. When dealing with content that changes in response to signals from a user or a server, the innerHTML approach soon becomes painful to maintain. We&#39;ll be taking a look inside the render function to see some of the ways React tries to solve this problem.</p>
</div></div>
<div class="topic" data-topic-id="headingId"><h1 id="react-render" class="heading">React.render</h1><div class="topic-content"><p>Let&#39;s take a step into <code>React.render</code> (you can use the <em>&quot;Source&quot;</em> link below the code snippet if you&#39;d like to see it in context):</p>
<div class="code-ref" data-lines="432,432"><pre><code class="lang lang-js">  render: function(nextElement, container, callback) {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L432">src/browser/ui/ReactMount.js:432</a></p></div><p>If you recall our <a class="wiki-link" href="#explore-react:hello-world" data-topic="Explore React" data-subheading="Hello World">Explore React&rarr;Hello World</a> example, <code>nextElement</code> is the <code>h1</code> we created, <code>container</code> is the <code>#example</code> DOM node, and we have omitted the <code>callback</code> parameter (this is optional).</p>
<p>At a high level we can describe this function in three steps:</p>
<ol>
<li><a href="#react-render:make-sure-we-39-re-rendering-a-valid-element">Make sure we&#39;re rendering a valid element</a></li>
<li><a href="#react-render:replace-it-or-reuse-it-">Work out whether to replace or reuse the previous element</a></li>
<li><a href="#react-render:render-a-new-component">Finally render a new component</a></li>
</ol>
<p>Before we go on it&#39;s interesting to note the use of the argument name <code>nextElement</code>. We should ask the question: why is it called &quot;next element&quot; and not just &quot;element&quot;? As mentioned earlier, React is not simply trying to render content to the page. Its main concern is in efficiently rendering <em>changing content</em>.  In that light the name <code>nextElement</code> makes more sense. When the content changes, rather than updating the DOM manually ourselves we simply create the &quot;next element&quot; and pass it to React to work out the best way to apply those changes. We&#39;ll also see later on how <code>nextElement</code> has a counterpart of <code>prevElement</code> (in <a class="wiki-link" href="#react-render:replace-it-or-reuse-it-" data-topic="React.render" data-subheading="Replace it or reuse it?">React.render&rarr;Replace it or reuse it?</a>).</p>
<h2 class="heading" id="react-render:make-sure-we-39-re-rendering-a-valid-element" data-topic="React.render">Make sure we&#39;re rendering a valid element</h2><p>The first thing the <code>render</code> function does is make sure we have a valid element. Placing this check at the function&#39;s entry-point follows the same idea as a booth to check your passport at a border crossing. Once we have verified that <code>nextElement</code> is a valid React element we can freely make assumptions on what to expect from it in all of the following function calls, without having to re-check each time.</p>
<p>React enforces the &quot;valid elements only&quot; rule by putting <code>React.isValidElement(nextElement)</code> inside a call to the <code>invariant</code> function. This function simply checks for a truthy first argument and throws an error otherwise:</p>
<div class="code-ref" data-lines="433,449"><pre><code class="lang lang-js">    invariant(
      ReactElement.isValidElement(nextElement),
      &#39;React.render(): Invalid component element.%s&#39;,
      (
        typeof nextElement === &#39;string&#39; ?
          &#39; Instead of passing an element string, make sure to instantiate &#39; +
          &#39;it by passing it to React.createElement.&#39; :
        typeof nextElement === &#39;function&#39; ?
          &#39; Instead of passing a component class, make sure to instantiate &#39; +
          &#39;it by passing it to React.createElement.&#39; :
        // Check if it quacks like an element
        nextElement != null &amp;&amp; nextElement.props !== undefined ?
          &#39; This may be caused by unintentionally loading two independent &#39; +
          &#39;copies of React.&#39; :
          &#39;&#39;
      )
    );
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L433-L449">src/browser/ui/ReactMount.js:433,449</a></p></div><p>The <code>invariant</code> function is a simple concept but there are still some interesting implementation details which you can read more about in <a class="wiki-link" href="#appendix:the-invariant-function" data-topic="Appendix" data-subheading="The invariant function">Appendix&rarr;The invariant function</a>.</p>
<p>In our example we&#39;re using a &quot;native element&quot; (representing an <code>&lt;h1&gt;</code>), so a lot of the complexity of dealing with elements won&#39;t apply here. You can read some more about elements in the <a class="wiki-link" href="#appendix:-elements" data-topic="Appendix" data-subheading="\Elements">Appendix&rarr;\Elements</a> section.</p>
<h2 class="heading" id="react-render:replace-it-or-reuse-it-" data-topic="React.render">Replace it or reuse it?</h2><p>As mentioned earlier, React&#39;s strength is in rendering changes. As we&#39;ll see further on, part of this strength comes from the fact that React makes the decision of whether to replace or reuse, freeing the developer from needing to handle both cases.</p>
<p>Looking further down in the <code>React.render</code> function we see a comparison of two elements to see whether we&#39;ll be updating a previously rendered element or rendering a new one:</p>
<div class="code-ref" data-lines="454,455"><pre><code class="lang lang-js">      var prevElement = prevComponent._currentElement;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L454-L455">src/browser/ui/ReactMount.js:454,455</a></p></div><p><code>prevComponent</code> is a component that was previously rendered to the <code>container</code> element. React looks up this information by storing component IDs. You can read more about that in the <a class="wiki-link" href="#appendix:react-ids" data-topic="Appendix" data-subheading="React IDs">Appendix&rarr;React IDs</a> section.</p>
<p>For now, let&#39;s take a look inside the <code>shouldUpdateReactComponent</code> function:</p>
<div class="code-ref" data-lines="28,28"><pre><code class="lang lang-js">function shouldUpdateReactComponent(prevElement, nextElement) {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/core/shouldUpdateReactComponent.js#L28">src/core/shouldUpdateReactComponent.js:28</a></p></div><p>First of all, if either <code>prevElement</code> or <code>nextElement</code> don&#39;t exist we can return straight away with the answer <em>&quot;Nope, don&#39;t update the component. Make a new one&quot;</em>:</p>
<div class="code-ref" data-lines="29,29"><pre><code class="lang lang-js">  if (prevElement != null &amp;&amp; nextElement != null) {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/core/shouldUpdateReactComponent.js#L29">src/core/shouldUpdateReactComponent.js:29</a></p></div><p>In the next couple of lines we see how the function handles scalar values. This is for the case where <code>prevElement</code> or <code>nextElement</code> is actually a string or a number rather than an element object. In this situation we can get our answer very quickly:</p>
<ul>
<li>Are <code>prevElement</code> and <code>nextElement</code> <em>both</em> scalars? Update.</li>
<li><code>prevElement</code> is a scalar but <code>nextElement</code> is an element object? Replace.</li>
</ul>
<div class="code-ref" data-lines="30,34"><pre><code class="lang lang-js">    var prevType = typeof prevElement;
    var nextType = typeof nextElement;
    if (prevType === &#39;string&#39; || prevType === &#39;number&#39;) {
      return (nextType === &#39;string&#39; || nextType === &#39;number&#39;);
    } else {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/core/shouldUpdateReactComponent.js#L30-L34">src/core/shouldUpdateReactComponent.js:30,34</a></p></div><p>Now, if <em>neither</em> are scalars we need to check some more things to answer the question. We will only update the previous component if all of the following are true:</p>
<ul>
<li>both elements must have the same <code>type</code> attribute (Note: this is different to what we get from <code>typeof</code>. In our example the type is <code>&#39;h1&#39;</code>, but it could be any custom element type you have defined).</li>
<li>both elements must have the same <code>key</code>. (You can read more about <a href="https://facebook.github.io/react/docs/multiple-components.html#dynamic-children">why keys are important in the React docs</a>)</li>
<li>both elements must have the same owner.</li>
</ul>
<div class="code-ref" data-lines="35,38"><pre><code class="lang lang-js">      if (nextType === &#39;object&#39; &amp;&amp;
          prevElement.type === nextElement.type &amp;&amp;
          prevElement.key === nextElement.key) {
        var ownersMatch = prevElement._owner === nextElement._owner;
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/core/shouldUpdateReactComponent.js#L35-L38">src/core/shouldUpdateReactComponent.js:35,38</a></p></div><p>This brings up an interesting concept. All of these checks are more or less saying <em>&quot;If the 2 elements are the same, update the content. Otherwise replace the old element with the new one&quot;</em>. Sounds pretty obvious when you say it like that. So why did we need to go to all of this trouble just to tell if two things are the same?  The clever thing about this approach is that React doesn&#39;t actually care whether the two things are the actual same element. It just needs to determine whether they are <em>close enough</em> to be able to efficiently transition from one to the next.</p>
<p>It&#39;s an important underlying concept to grasp when using React. You&#39;ll notice that when you write your own custom elements, the <code>render</code> function returns new elements every time it is executed. If you&#39;re used to other paradigms this can feel strange because normally we associate &quot;creating something&quot; with having a significant cost. The instinct then is to locate the existing element ourselves and update it, to avoid the waste of creating a new one. React turns this idea upside down. Creating a React element is cheap, so we just create every time and leave it to React to decide how to render it.  Not only will the end result be more efficient than if we updated DOM elements manually, our code is also much cleaner, going from two execution paths (eg. &quot;update? create?&quot;) to one.</p>
<p>In the case of our &quot;Hello World&quot; example, there won&#39;t be any <code>prevComponent</code>.  But if there was we would either update that component:</p>
<div class="code-ref" data-lines="455,461"><pre><code class="lang lang-js">      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        return ReactMount._updateRootComponent(
          prevComponent,
          nextElement,
          container,
          callback
        ).getPublicInstance();
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L455-L461">src/browser/ui/ReactMount.js:455,461</a></p></div><p>or remove the existing one before proceeding to render the new element:</p>
<div class="code-ref" data-lines="462,464"><pre><code class="lang lang-js">      } else {
        ReactMount.unmountComponentAtNode(container);
      }
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L462-L464">src/browser/ui/ReactMount.js:462,464</a></p></div><h2 class="heading" id="react-render:render-a-new-component" data-topic="React.render">Render a new component</h2><p>To recap, we&#39;ve determined that there is no existing component, and we want to render a new one. We call the <code>_renderNewRootComponent</code> function:</p>
<div class="code-ref" data-lines="492,496"><pre><code class="lang lang-js">    var component = ReactMount._renderNewRootComponent(
      nextElement,
      container,
      shouldReuseMarkup
    ).getPublicInstance();
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L492-L496">src/browser/ui/ReactMount.js:492,496</a></p></div><p>Let&#39;s take a look at where that function is defined:</p>
<div class="code-ref" data-lines="377,381"><pre><code class="lang lang-js">  _renderNewRootComponent: function(
    nextElement,
    container,
    shouldReuseMarkup
  ) {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L377-L381">src/browser/ui/ReactMount.js:377,381</a></p></div><p>The first thing we see here is a warning against nested updates, by making sure the <code>ReactCurrentOwner.current</code> is <code>null</code>. The &quot;current owner&quot; is whichever component is running its <code>render</code> function.</p>
<div class="code-ref" data-lines="385,391"><pre><code class="lang lang-js">    warning(
      ReactCurrentOwner.current == null,
      &#39;_renderNewRootComponent(): Render methods should be a pure function &#39; +
      &#39;of props and state; triggering nested component updates from &#39; +
      &#39;render is not allowed. If necessary, trigger nested updates in &#39; +
      &#39;componentDidUpdate.&#39;
    );
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L385-L391">src/browser/ui/ReactMount.js:385,391</a></p></div><p>Next we instantiate the component and register it. This gives us an ID that is used to refer to the component internally (See <a class="wiki-link" href="#appendix:registering-a-component" data-topic="Appendix" data-subheading="Registering a component">Appendix&rarr;Registering a component</a> for more on that topic):</p>
<div class="code-ref" data-lines="393,397"><pre><code class="lang lang-js">    var componentInstance = instantiateReactComponent(nextElement, null);
    var reactRootID = ReactMount._registerComponent(
      componentInstance,
      container
    );
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L393-L397">src/browser/ui/ReactMount.js:393,397</a></p></div><p>Finally the update is batched so that React can perform several DOM updates together and <a href="http://stackoverflow.com/questions/510213/when-does-reflow-happen-in-a-dom-environment">avoid unecessary reflow</a>:</p>
<div class="code-ref" data-lines="403,409"><pre><code class="lang lang-js">    ReactUpdates.batchedUpdates(
      batchedMountComponentIntoNode,
      componentInstance,
      reactRootID,
      container,
      shouldReuseMarkup
    );
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L403-L409">src/browser/ui/ReactMount.js:403,409</a></p></div><p>There&#39;s a lot of interesting things happening inside <code>ReactUpdates.batchedUpdates</code>, and it probably deserves a separate post all to itself. We&#39;ve only just scratched the surface, but my hope is that what we&#39;ve looked at here will be enough to get you started on your own exploration. Adventure awaits!</p>
</div></div>
<div class="topic" data-topic-id="headingId"><h1 id="appendix" class="heading">Appendix</h1><div class="topic-content"><h2 class="heading" id="appendix:elements" data-topic="Appendix">Elements</h2><p>React keeps the definition of an &quot;element&quot; very simple. Rather than trying to abstract the general behaviour of every possible kind of element, a <code>ReactElement</code> is just a javascript object which follows a certain strucutre.</p>
<h3 class="heading" id="appendix:what-makes-a-valid-element-" data-topic="Appendix">What makes a valid element?</h3><p>How does React know if it is dealing with an element or some other type of object? Often when faced with this question you might reach for <code>instanceof</code> but a decision was made here to use the more flexible <a href="https://en.wikipedia.org/wiki/Duck_typing">Duck Typing</a> approach. There&#39;s a reference to this in the comments:</p>
<div class="code-ref" data-lines="443,443"><pre><code class="lang lang-js">        // Check if it quacks like an element
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L443">src/browser/ui/ReactMount.js:443</a></p></div><p>Stepping into the <code>isValidElement</code> function we check for the element&#39;s &quot;quack&quot; by looking for the presence of a special flag, <code>_isReactElement</code>:</p>
<div class="code-ref" data-lines="295,295"><pre><code class="lang lang-js">  var isElement = !!(object &amp;&amp; object._isReactElement);
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/classic/element/ReactElement.js#L295">src/classic/element/ReactElement.js:295</a></p></div><p>The flag is set on the <code>ReactElement</code> prototype defined earlier in that same file:</p>
<div class="code-ref" data-lines="140,143"><pre><code class="lang lang-js">// ReactElement should be indistinguishable from a plain object.
ReactElement.prototype = {
  _isReactElement: true
};
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/classic/element/ReactElement.js#L140-L143">src/classic/element/ReactElement.js:140,143</a></p></div><h2 class="heading" id="appendix:registering-a-component" data-topic="Appendix">Registering a component</h2><ul>
<li>TODO: monitor scrolling (so that React can handle this internally):</li>
</ul>
<div class="code-ref" data-lines="363,363"><pre><code class="lang lang-js">    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L363">src/browser/ui/ReactMount.js:363</a></p></div><ul>
<li>TODO: register the container</li>
</ul>
<div class="code-ref" data-lines="365,365"><pre><code class="lang lang-js">    var reactRootID = ReactMount.registerContainer(container);
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L365">src/browser/ui/ReactMount.js:365</a></p></div><ul>
<li>store a reference to the component instance by ID:</li>
</ul>
<div class="code-ref" data-lines="366,366"><pre><code class="lang lang-js">    instancesByReactRootID[reactRootID] = nextComponent;
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L366">src/browser/ui/ReactMount.js:366</a></p></div><h2 class="heading" id="appendix:react-ids" data-topic="Appendix">React IDs</h2><div class="code-ref" data-lines="451,451"><pre><code class="lang lang-js">    var prevComponent = instancesByReactRootID[getReactRootID(container)];
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/browser/ui/ReactMount.js#L451">src/browser/ui/ReactMount.js:451</a></p></div><ul>
<li><p>TODO: how are IDs generated?</p>
</li>
<li><p>TOOD: how are they used?</p>
</li>
</ul>
<h2 class="heading" id="appendix:the-invariant-function" data-topic="Appendix">The invariant function</h2><div class="code-ref" data-lines="14,25"><pre><code class="lang lang-js">/<em>*
 </em> Use invariant() to assert state which your program assumes to be true.
 <em>
 </em> Provide sprintf-style format (only %s is supported) and arguments
 <em> to provide information about what broke and what you were
 </em> expecting.
 <em>
 </em> The invariant message will be stripped in production, but the invariant
 <em> will remain to ensure logic does not differ in production.
 </em>/

var invariant = function(condition, format, a, b, c, d, e, f) {
</code></pre><p>source: <a target="_blank" href="https://github.com/facebook/react/blob/v0.13.0-rc1//src/vendor/core/invariant.js#L14-L25">src/vendor/core/invariant.js:14,25</a></p></div><p>You might wonder why the invariant function uses those <code>a, b, c, d, e, f</code> arguments. These are used to create the error message. <code>format</code> is a string template, and <code>a</code> to <code>f</code> are substituted any place <code>format</code> contains the string <code>%s</code>.</p>
<p>But can&#39;t we use <code>arguments</code> if we need to support a varying number of arguments to our function? Yes we can, but there is some performance overhead. Since React uses <code>invariant</code> quite often, and in some performance-critical code, even a little gain will be worthwhile. A quick google showed a <a href="http://jsperf.com/invariant-with-and-without-explicit-parameters">jsperf experiment on this topic</a> if you&#39;re interested in some numbers.</p>
<ul>
<li><p>TODO: stripping out the message for production</p>
</li>
<li><p>TODO: <code>error.framesToPop</code></p>
</li>
</ul>
</div></div></div><script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
function dedupe (acc, item) {
  if (acc.indexOf(item) === -1) { acc.push(item); }
  return acc;
}

module.exports = dedupe;

},{}],2:[function(require,module,exports){
/*

  Create a unique anchor ID by converting the heading text into a suitable format.

*/
module.exports = function getHeadingId (raw) {
  return raw.trim().toLowerCase().replace(/[^\w]+/g, '-');
};

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')
require('html-element')

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        var m = split(string, /([\.#]?[a-zA-Z0-9_:-]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  e.style.setProperty(s, l[k][s])
              })(s, l[k][s])
            }
          } else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function isText (el) {
  return el && el.nodeName === '#text' && el.nodeType == 3
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}

},{"browser-split":5,"class-list":6,"html-element":3}],5:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],6:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":7}],7:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],8:[function(require,module,exports){
var h = require('hyperscript');
var innerText = require('./inner-text');

function addAnchor (header) {
  var headerText = innerText(header);
  var anchor = h('a', {
    href: '#' + header.id
  }, headerText);

  header.innerHTML = anchor.outerHTML;
}

module.exports = addAnchor;

},{"./inner-text":9,"hyperscript":4}],9:[function(require,module,exports){
function innerText (elem) {
  return elem.innerText || elem.textContent;
}

module.exports = innerText;

},{}],10:[function(require,module,exports){
var h = require('hyperscript');
var d = document;

var addAnchor = require('./add-anchor');
var dedupe = require('../lib/dedupe');
var getHeadingId = require('../lib/get-heading-id');
var innerText = require('./inner-text');
var setupHighlighter = require('./setup-highlighter');

function getTopicElem (id) {
  return d.getElementById(id);
}

function getContentHolderElem () {
  return d.querySelector('.content');
}

function showTopic (topic) {
  var elem = (typeof topic === 'string') ?
      getTopicElem(topic) :
      topic;

  if (!elem) {
    throw new Error('topic not found: ' + topic);
  }
}

function getCurrentLocationHash () {
  return window.location.hash.replace(/^\#/, '');
}

function handleHashChange (event) {
  var hash = getCurrentLocationHash();
  showTopic(hash);
}

function findNearestHeading (elem) {
  var prev;
  while (elem) {
    prev = elem.previousElementSibling;
    if (!prev) {
      prev = elem.parentElement;
    }

    if (!prev) { throw new Error('no heading found'); }

    // found a heading
    if (prev.nodeName.toLowerCase().match(/^h(\d)$/)) {
      return prev;
    }

    // keep stepping back/up until a heading is found
    elem = prev;
  }
}

function createIncomingLinksElem (topicHeading) {
  var currentTopicId = getHeadingId(topicHeading);
  var foundLinks = d.querySelectorAll('a[data-topic="' + topicHeading + '"]');
  var foundHeadings = [].map.call(foundLinks, findNearestHeading)
      .reduce(dedupe, [])
      .filter(function (elem) {
        var id = elem.getAttribute('id');

        // filter out this item if it is a link from within the same topic
        if (id === currentTopicId ||
            id.indexOf(currentTopicId + ':') === 0) { return false; }

        return true;
      });

  if (!foundHeadings.length) { return null; }

  var listItems = foundHeadings.map(function (elem) {
    var parts;
    var topicHeading;
    var subHeading;
    var id = elem.getAttribute('id');

    if (elem.nodeName === 'H1') {
      topicHeading = innerText(elem);
      parts = [topicHeading];
    }
    else {
      topicHeading = elem.getAttribute('data-topic');
      subHeading = innerText(elem);
      parts = [topicHeading, subHeading];
    }

    var anchorElem = h('a', { href: '#' + id });
    anchorElem.innerHTML = parts.join('&rarr;');

    return h('li', null, anchorElem);
  });

  var elem = h('div.incoming', null, [
    h('h2', null, 'Linked from:'),
    h('ul', null, listItems)
  ]);

  return elem;
}

function getHeadingOffsets () {
  return [].map.call(d.querySelectorAll('.heading'), function(heading) {
    var buffer = heading.nodeName.toLowerCase() === 'h1' ? 50 : 10;
    return heading.offsetTop - buffer;
  });
}

function updateStickyHeader (headingOffsets) {
  var container = d.body;
  var stickyElem = d.querySelector('h1.sticky');
  var scrollTop = container.scrollTop;
  var found;

  // find the first heading equal or greater than the scroll offset
  for (var i = 0; i < headingOffsets.length; i += 1) {
    if (headingOffsets[i] >= scrollTop) { found = i; break; }
  }

  if (found === undefined) { found = headingOffsets.length; }

  // we actually want the heading before
  found = Math.max(0, found - 1);

  var heading = d.querySelectorAll('.heading')[found];
  var topic = heading.getAttribute('data-topic');

  stickyElem.innerHTML = !!topic ?
    '<small>' + topic + '</small>' + innerText(heading):
    innerText(heading);
}

// ----

window.onhashchange = handleHashChange;

[].forEach.call(d.querySelectorAll('.content > .topic'), function (topicElem) {
  var topicId = topicElem.getAttribute('id');
  var h1 = topicElem.querySelector('h1');
  var heading = innerText(h1);

  var elem = createIncomingLinksElem(heading);
  if (elem) {
    topicElem.appendChild(elem);
  }
});

[].forEach.call(d.querySelectorAll('.heading'), addAnchor);

var stickyElem = h('h1.sticky');
d.body.appendChild(stickyElem);

var headingOffsets = getHeadingOffsets();
var update = updateStickyHeader.bind(null, headingOffsets);
update();
d.onscroll = update;

setTimeout(setupHighlighter, 100);

},{"../lib/dedupe":1,"../lib/get-heading-id":2,"./add-anchor":8,"./inner-text":9,"./setup-highlighter":11,"hyperscript":4}],11:[function(require,module,exports){
var d = document;
var h = require('hyperscript');

// load syntax highlighting code
function loadHighlighter () {
  var headElem = d.querySelector('head');

  headElem.appendChild(h('link', {
    rel: 'stylesheet',
    href: 'http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css'
  }));

  headElem.appendChild(h('script', {
    src: 'http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js'
  }));

  var interval = setInterval(function () {
    if (!!window.hljs) {
      clearInterval(interval);
      applyHighlighter();
    }
  }, 100);
}

function applyHighlighter () {
  [].forEach.call(d.querySelectorAll('code.lang'), hljs.highlightBlock);
}

module.exports = loadHighlighter;

},{"hyperscript":4}]},{},[10]);
</script></body></html>